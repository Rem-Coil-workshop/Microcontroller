# Микроконтроллер
В качестве микроконтроллера выступает Arduino Mega. Он открывает и закрывает ячейки.

В начале скетча указываются параметры:
* Время открытия `const int openDelay = 15000;`
* Количество дверей `const int doorsCount = 4;`
* Пины, к которым подключены ячейки `const int doors[] = {7, 6, 5, 4};`

Далее идет два массива состояний ячеек: первый - открыта или закрыта соответствующая ячейка, второй - время последнего открытия (в милисекундах). 

В функции `setup()` происходит конфигурация скетча:
* Устанавливается I2C соединение и указывается порт: `Wire.begin(0x8);`
* Указывается функция, которая будет обрабатывать прерывания: `Wire.onReceive(receiveEvent);`
* Инициализируются пины, к которым подключены ячейки

Прерывания обрабатывает функция `void receiveEvent(int howMany)`. В ней считывается полученное по протоколу значение ячейки и для неё меняется состояние: 
* Устанавливается флаг в положение открыто 
* Указывается время открытия.
```c++
void receiveEvent(int howMany) {
  while (Wire.available()) {
    int digit = Wire.read() - 1;
    doorsOpened[digit] = true;
    doorsTime[digit] = millis();
  }
```

В методе `loop()` сначала обновляется состояние ячеек и потом открываются необходимые ячейки.
```c++
void loop() {
  updateDoors();
  openDoors();
}
```
При обновлении ячеек, программа смотрит сколько прошло с момента открытия ячейки, и, если это значение больше значения, которое было задано в начале, функция учтанавливает флаги в положение закрыто.
```c++
void updateDoors() {
  for (int i = 0; i < doorsCount; i++){
    if (doorsOpened[i] and millis() - doorsTime[i] > openDelay) {
      doorsOpened[i] = false;
    } 
  }
}
```
В функции открытия ячеек на ячееки, которые помечены открытыми, подаётся напряжение, иначе напряжение выключется.
```c++
void openDoors() {
 for (int i = 0; i < doorsCount; i++) {
  if (doorsOpened[i]) {
   digitalWrite(doors[i], HIGH);
  } else {
   digitalWrite(doors[i], LOW);
  }
 }
}
```
